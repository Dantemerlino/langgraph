# Workplan: FEAT-InteractiveLauncher - Interactive Agentic System Launcher

**Document Version:** 1.1
**Date:** 2024-03-11
**Author:** AI Assistant
**Status:** Proposed

## 1. Introduction and Goals

This document outlines the workplan for **FEAT-InteractiveLauncher**, a new feature to provide an interactive graphical user interface (GUI) for launching and observing the agentic system.

The primary goals of this feature are:
-   To offer a user-friendly alternative to CLI execution for the agentic system (`graph.py`).
-   To allow users to input their queries directly into a GUI.
-   To display the intermediate steps, agent outputs, and the final answer in a structured, multi-pane layout.
-   To facilitate easier testing and demonstration of the agentic system's capabilities.
-   To enable configuration of key parameters, such as BigQuery connection details (via `.env` integration).
-   To provide a mechanism for saving session outputs (user input, intermediate steps, final answer, performance metrics).
-   To collect basic performance metrics and user feedback.

This feature will enhance the usability and observability of the existing agentic system.

## 2. Requirements

### 2.1. Functional Requirements
-   **FR1 (User Input)**: The GUI must provide a text area for users to input their natural language query.
-   **FR2 (Launch Control)**: A "Run" or "Execute" button must trigger the execution of the agentic system (`graph.py`) with the provided user input.
-   **FR3 (Configuration - BigQuery)**:
    -   The launcher must be able_ to load BigQuery connection details (e.g., Project ID, Dataset, Credentials Path) from a `.env` file.
    -   The GUI should provide a way to specify the path to the `.env` file or have a default location (e.g., project root).
    -   The GUI should indicate if the `.env` file was successfully loaded or if there are issues.
    -   *(Future consideration: GUI fields to directly input these details, with an option to save them to a `.env` file).*
-   **FR4 (Display - Intermediate Steps)**: A dedicated pane/area must display the sequence of agents being executed and the data/state output by each agent node (similar to the current `app.stream()` console output).
-   **FR5 (Display - Final Answer)**: A dedicated pane/area must clearly display the final answer generated by the system (from `AnswerState`).
-   **FR6 (Display - SQL Queries)**: If the `retrieve_data_agent` generates SQL queries (even simulated ones), these queries should be displayed, ideally in a separate, formatted pane.
-   **FR7 (Display - Performance Metrics)**:
    -   The GUI must display basic performance metrics:
        -   Total execution time of the graph.
        -   Time taken by each agent node.
    -   *(Future consideration: More detailed metrics like token counts if LLM calls are made).*
-   **FR8 (Save Session Output)**:
    -   A "Save Session" button must allow users to save the entire session's context to a structured file (e.g., JSON or Markdown).
    -   Saved data should include:
        -   Original user input.
        -   All intermediate agent outputs (from FR4).
        -   Generated SQL queries (from FR6).
        -   The final answer (from FR5).
        -   Performance metrics (from FR7).
        -   User feedback (from FR9, if provided).
-   **FR9 (User Feedback)**:
    -   The GUI should provide a simple mechanism for users to give feedback on the result (e.g., a "üëç Like" / "üëé Dislike" button pair, and an optional text field for comments).
    -   This feedback should be included in the saved session output.
-   **FR10 (Clear/Reset)**: A "Clear" or "Reset" button to clear all input fields, display panes, and reset the internal state of the launcher for a new query.

### 2.2. Non-Functional Requirements
-   **NFR1 (Usability)**: The GUI should be intuitive, easy to use, and visually appealing.
-   **NFR2 (Responsiveness)**: The GUI should remain responsive during agent execution (e.g., using background threads for the LangGraph process).
-   **NFR3 (Platform Compatibility)**: The chosen GUI framework should be cross-platform (Windows, macOS, Linux).
-   **NFR4 (Error Handling)**: The GUI must gracefully display errors from the agentic system or internal GUI errors.
-   **NFR5 (Modularity)**: The launcher code should be modular and well-separated from the core agentic system logic in `graph.py`.

### 2.3. Out of Scope for Initial Version
-   Advanced configuration options directly in the GUI (beyond `.env` path).
-   Real-time editing of agent configurations.
-   Saving/loading of specific graph states beyond session output.
-   User authentication/authorization.

## 3. Proposed Design and Implementation

### 3.1. GUI Framework Proposal
-   **Primary Framework**: **PySide (Qt for Python)**
    -   **Rationale**: PySide (via its `PySide6` package, providing LGPL-licensed Qt6 bindings) allows for the creation of robust, feature-rich, and visually appealing cross-platform desktop applications. It offers a comprehensive set of widgets and tools that can effectively handle complex layouts with multiple resizable panes (e.g., using `QSplitter`), rich text display, formatted tables (e.g., `QTableView` for structured data or metrics), and custom interactions. While Qt is a large framework, careful selection of modules (e.g., `QtWidgets`, `QtCore`, `QtGui`) can help manage the application's footprint. It is free to use for both open-source and commercial applications under the LGPL. This choice aligns well with the desire for a professional-looking and highly functional desktop utility.
-   **Secondary Alternative**: **Streamlit**
    -   **Rationale**: Streamlit allows for very rapid development of interactive UIs, primarily web-based but runnable locally. It excels at data display and requires minimal boilerplate code to create interactive elements like text inputs, buttons, and data tables. This could be a faster path to an MVP if a browser-based local launcher is acceptable and if the layout constraints of Streamlit are manageable for the desired multi-pane view. It's free and handles many UI elements automatically.

### 3.2. High-Level Architecture
1.  **`InteractiveLauncherApp(QMainWindow)` (Main Class - PySide)**: Manages the PySide GUI, event handling (signals and slots), and communication with the agentic system.
2.  **Configuration Manager (`.env` loader)**: A utility module/class to load and parse the `.env` file for BigQuery configurations.
3.  **Agentic System Interface**: A wrapper or set of functions (potentially using Qt's threading capabilities like `QThread` and signals/slots for communication) to invoke `graph.py`'s `app.stream()` or `app.invoke()` and pipe its outputs back to the GUI.
4.  **Display Panes (PySide)**: Separate widgets like `QTextEdit` (for rich text display of logs, answers), `QTableView` (for structured data if applicable), organized within `QSplitter` for resizable panes.
    -   User Input (`QTextEdit`)
    -   Intermediate Steps/Logs (`QTextEdit`)
    -   SQL Queries (`QTextEdit` with potential syntax highlighting if a suitable library is integrated)
    -   Final Answer (`QTextEdit`)
    -   Performance Metrics & Feedback (`QFormLayout` for metrics, buttons, and a `QTextEdit` for comments)
5.  **Session Data Model**: A Python dictionary or Pydantic model to structure session data before saving.

### 3.3. Key Implementation Details
-   **`.env` Handling**:
    -   Use a library like `python-dotenv` (add to `requirements.txt`).
    -   The application will look for a `.env` file in its root directory by default. A `QFileDialog` can be used to allow specifying an alternative path.
    -   Loaded environment variables will be passed to `bigquery_tools.py`.
-   **Running LangGraph in a Thread (PySide)**:
    -   Use `QThread` for running the LangGraph process to prevent GUI freezing.
    -   Use Qt's signals and slots mechanism to pass messages (agent outputs, logs, final answer, errors) from the worker `QThread` back to the main GUI thread for display.
-   **Capturing Agent Output**:
    -   LangGraph's `stream` events are the primary source. These events will be emitted as signals from the worker thread.
    -   If direct `print()` statements need capturing, `contextlib.redirect_stdout` can still be used within the worker thread, with captured output also emitted via signals.
-   **SQL Display**:
    -   The `retrieve_data_agent` (and `bigquery_tools.py`) will need to ensure SQL queries are part of the streamed events or explicitly passed back. Display in a `QTextEdit`.
-   **Performance Metrics**:
    -   Wrap calls to agent nodes and the overall graph invocation with `time.perf_counter()` in the worker thread. Emit results via signals.
-   **Save Functionality**:
    -   Use `QFileDialog.getSaveFileName` to get the save path.
    -   Format session data as JSON (using `json.dump`) or Markdown.
-   **GUI Layout (PySide)**:
    -   Main window using `QMainWindow`.
    -   `QSplitter` for resizable panes.
    -   Layout managers like `QVBoxLayout`, `QHBoxLayout`, `QGridLayout`, `QFormLayout` within widgets and panes.
    -   `QTextEdit` for most multi-line text display.

## 4. Task Breakdown and Milestones

*Note: Effort estimations for GUI tasks (LCH-001, LCH-004) are kept but may require slight adjustment based on team familiarity with PySide vs. the initial tkinter estimate.*

| Task ID | Description                                       | Subtasks (Examples)                                                                                                | Estimated Effort | Priority | Status      | Dependencies |
| :------ | :------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------- | :--------------- | :------- | :---------- | :----------- |
| LCH-001 | Basic GUI Structure (PySide)                      | Setup `QMainWindow`, input area (`QTextEdit`), run button (`QPushButton`), basic response area (`QTextEdit`).            | 1-1.5 days       | High     | To Do       | -            |
| LCH-002 | `.env` Configuration Loading                      | Implement `.env` file loading (e.g., `python-dotenv`), GUI element for path (`QLineEdit`, `QPushButton` for dialog). | 0.5 days         | High     | To Do       | -            |
| LCH-003 | LangGraph Integration (Threaded - QThread)        | Create `QThread` worker, interface to run `graph.py`, pipe output via signals to GUI slots.                        | 1.5-2 days       | High     | To Do       | LCH-001      |
| LCH-004 | Multi-Pane Display Implementation (PySide)        | Design and implement panes using `QSplitter`, `QTextEdit` for Intermediate Steps, Final Answer, SQL, Performance.  | 2-2.5 days       | High     | To Do       | LCH-001      |
| LCH-005 | Display Intermediate Steps                        | Connect to signals from worker thread, format and display LangGraph stream events in "Intermediate Steps" pane.    | 1 day            | High     | To Do       | LCH-003, LCH-004 |
| LCH-006 | Display Final Answer                            | Extract final answer from graph output (via signal), display in "Final Answer" pane.                               | 0.5 days         | High     | To Do       | LCH-003, LCH-004 |
| LCH-007 | SQL Query Display                               | Ensure `retrieve_data_agent` exposes SQL via stream; display in "SQL Queries" pane.                                | 1 day            | Medium   | To Do       | LCH-003, LCH-004 |
| LCH-008 | Performance Metrics Calculation & Display         | Implement timing in worker thread; display in "Performance" pane (e.g., using `QFormLayout`).                      | 1 day            | Medium   | To Do       | LCH-003, LCH-004 |
| LCH-009 | User Feedback Implementation                      | Add `QPushButton` (Like/Dislike), optional `QTextEdit` for comments; integrate into session data.                  | 0.5 days         | Medium   | To Do       | LCH-001      |
| LCH-010 | Save Session Functionality                        | Implement "Save Session" button (`QFileDialog`), collect data, save as JSON/Markdown.                              | 1 day            | High     | To Do       | LCH-005, LCH-006, LCH-007, LCH-008, LCH-009 |
| LCH-011 | Clear/Reset Functionality                         | Implement "Clear" button to reset GUI elements.                                                                    | 0.5 days         | Medium   | To Do       | LCH-001      |
| LCH-012 | Error Handling and GUI Refinements                | Implement robust error display (e.g., `QMessageBox`); general UI/UX improvements using Qt features.                | 1-1.5 days       | Medium   | To Do       | All others   |
| LCH-013 | Documentation & Testing                           | Write user guide for launcher; perform thorough testing.                                                           | 1.5 days         | High     | To Do       | All others   |

**Total Estimated Effort**: ~12.5 - 15 days (reflecting potential increase for PySide)

**Key Milestones**:
-   **M1**: Basic PySide GUI with input, run, and raw output display (LCH-001, LCH-003 partial).
-   **M2**: Configuration loading and multi-pane display structure functional (LCH-002, LCH-004).
-   **M3**: Full display of intermediate steps, final answer, SQL, and performance metrics (LCH-005, LCH-006, LCH-007, LCH-008).
-   **M4**: Save session and user feedback implemented (LCH-009, LCH-010).
-   **M5**: Feature complete, tested, and documented (LCH-011, LCH-012, LCH-013).

## 5. Testing Strategy
(No changes from previous version, still relevant)
-   **Unit Testing**:
    -   Test `.env` loading logic independently.
    -   Test data formatting functions for display panes.
    -   Test session data aggregation logic.
-   **Integration Testing**:
    -   Test the interface between the GUI and the LangGraph execution thread (message passing).
    -   Test the flow of data from user input through graph execution to all display panes.
-   **User Acceptance Testing (UAT)**:
    -   Manual testing of all GUI functionalities.
    -   Verify usability and intuitiveness of the interface.
    -   Test on different platforms if possible.

## 6. Assumptions and Dependencies

-   **Assumption 1**: The core agentic system in `graph.py` is relatively stable and provides mechanisms to stream or return its state changes and final output.
-   **Assumption 2**: **PySide6** is a suitable and acceptable GUI framework for this project.
-   **Dependency 1**: Python 3.8+ environment.
-   **Dependency 2**: `langgraph`, `pydantic`, `requests` (already in `requirements.txt`).
-   **Dependency 3**: `python-dotenv` (will be added to `requirements.txt`).
-   **Dependency 4**: `PySide6` (will be added to `requirements.txt`).

## 7. Risks and Mitigation

-   **Risk 1 (GUI Responsiveness)**: LangGraph execution might block the GUI.
    -   **Mitigation**: Run LangGraph in a separate `QThread` and use signals/slots for communication, as planned.
-   **Risk 2 (Complexity of Output Parsing)**: Capturing and formatting all desired outputs (stdout, agent states, SQL) might be complex.
    -   **Mitigation**: Iterative development. Prioritize capturing LangGraph stream events. If necessary, adapt agent functions to return data more explicitly for GUI consumption.
-   **Risk 3 (Cross-Platform UI Inconsistencies)**: While Qt/PySide is good, minor platform-specific rendering issues or behaviors can occur.
    -   **Mitigation**: Test on target platforms. Focus on functional consistency. Adhere to standard Qt styling where possible before attempting complex custom styling.
-   **Risk 4 (Scope Creep)**: Requests for more advanced GUI features during development.
    -   **Mitigation**: Adhere strictly to the defined requirements for the initial version. Log additional requests for future iterations.
-   **Risk 5 (Learning Curve for PySide)**: If the development team is less familiar with PySide/Qt, initial development might be slower.
    -   **Mitigation**: Allocate time for learning, leverage PySide documentation and examples. Start with simpler UI components and build incrementally.

## 8. Future Considerations (Post-MVP)
(No changes from previous version, still relevant)
-   Direct GUI fields for BigQuery configuration (with save to `.env`).
-   Ability to select different LLM models or endpoints if the system supports it.
-   Graph visualization within the GUI.
-   Loading saved sessions back into the launcher for review.
-   More advanced performance metrics and logging.

---
This workplan provides a roadmap for developing the Interactive Launcher. It will be updated as the project progresses.
